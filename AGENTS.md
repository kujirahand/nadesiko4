# AGENTS: Nadesiko4 (Rust製スクリプト言語)

## 目的

- Rustで作るNadesiko4スクリプト言語の共通方針をまとめる。
- 初学習コストを下げるため、まずこれを読み、必要に応じてリンク先を参照する。

## 対象範囲

- Rust実装のコアランタイムと標準ライブラリ。
- 字句解析器・構文解析器・AST・VM/実行器・ホストバインディング・CLI(REPL/コンパイラ)。
- 言語仕様のルールと互換性ポリシー。

## 原則

- 正しさ最優先: 挙動は決定的でエラーメッセージは明確に。
- 読みやすいRust: 小さなモジュール、明示的な型、狭いトレイト。
- 予測可能な言語面: サプライズを避け、文法と意味を先に文書化。
- テストは仕様: 各機能に Lexer/Parser/Exec のテストを用意。

## アーキテクチャ概要

- Lexer: UTF-8ソースをトークン化。
- Parser: 型付きASTを生成。エラーはスパンとヒントを含める。
- セマンティック層: シンボル解決、軽量な型付け、制御フロー検証。
- VM/Executor: スタックベースで明確なオペコード集合。ホストI/Oはトレイトで分離。
- 標準ライブラリ: 小さく安全なラッパー。OS/ファイル/ネットは可能ならfeature flag越し。
- CLI: `nadesiko4` バイナリ

## コーディング規約

- Rust 2021版。`clippy`クリーンを目指す。
- `unsafe`禁止。やむを得ず使う場合はコメントとテストを付け、1モジュールに隔離。
- エラーはスパン+種類+メッセージの構造化。
- ログは`tracing`。CLI出力はユーザーフレンドリーかつ安定。
- データ構造は小さなenum(token/ast/opcode)を好み、過剰な割当を避ける。

## 言語仕様 (MVP)

- エンコーディング: UTF-8。
- コメント: `#`で行末まで。
- 識別子: Unicodeの文字・数字・`_`を許容(先頭は数字不可)。
- リテラル: 整数、浮動小数、文字列("…"), 真偽値(真|偽), null。
- 制御構文: `もし/違えば`、`Nの間`、`繰り返す`、`関数`、`戻る`、`抜ける`、`続ける`。
- データ: 配列`[...]`、マップ`{key: value}`、関数は第一級。
- 組み込み: 基本算術、比較、`要素数`、`表示`、配列/マップ操作。
- セミコロン: 文末で任意。ただし曖昧さ回避のために必要な場合は必須。

## テストと品質

- ユニットテストはモジュール隣接、統合テストは`tests/`配下。
- 各言語機能にLexer/Parser/Execテストを追加。
- PR前に`cargo fmt`、`cargo clippy --all-targets --all-features`、`cargo test`を実行。
- バグ修正には必ず回帰テストを追加。

## リリース

- バージョンはCargoで管理し、タグは`vX.Y.Z`。
- 言語仕様変更やCLIフラグはChangelogに記載。
- リリースビルド: `cargo build --release`。最小限のスモークテストを同梱。

## 変更時チェックリスト

- 言語変更やバグ内容を明確に記述。
- 文法が変わる場合はドキュメントを更新。
- テスト(Lexer/Parser/Exec)を追加し、フィクスチャは最小限に。
- fmt/clippy/testを実行。
- CLIの挙動が変わる場合はREADMEやヘルプも更新。

## コミュニケーション

- PRは小さくレビューしやすく。
- 文法やオペコードなどの決定はコメントまたは後続ドキュメントに残す。

## 用語集

- AST: Abstract Syntax Tree。
- VM: Virtual Machine。バイトコード/オペコードを実行。
- Span: ソース中のバイト範囲。エラーレポートに使用。

## CLIコマンド

- `nadesiko4 <file>`: スクリプトファイルを実行
- `nadesiko4 -e '<source>'`: 直接ソースコードを実行
- `nadesiko4 --help`: ヘルプを表示
- `nadesiko4 --version`: バージョン情報を表示
- `nadesiko4 (--debug|-D)`: デバッグモードで実行

## 実行までの仕組み

1. ソース文字列から`Source`を生成し、行・桁を持ったカーソルで1文字ずつ走査
2. `lexer::lex`が数字/文字列/単語/記号を判別し、`pos`と助詞`josi`付き`Vec<Token>`へ分割（未対応文字は`Nop`）
3. `parser::parse`がトークン列を読み、値付きASTノードをスタック経由で組み立て、`Print`などの構文でルートに確定
4. `ast_to_bytecode::ast_to_bytecodes`がASTをたどり、`NakoSystem`にオペコード列とリテラル(文字列/数値)を積む
5. `vm::run`がスタックVMでバイトコードを逐次実行し、演算結果や`表示`の文字列を`output`へ追記
6. 実行完了時に`output`を返し、エラーがあればエラーメッセージ文字列を返す
